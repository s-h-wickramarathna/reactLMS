{"ast":null,"code":"'use client';\n\nimport { useState, useEffect } from 'react';\n/**\n * useIntersectionObserver Hook\n *\n * @param ref - Ref object of the element to be observed\n */\n\nvar useIntersectionObserver = function useIntersectionObserver(ref) {\n  var _useState = useState(false),\n    isVisible = _useState[0],\n    setIsVisible = _useState[1];\n  useEffect(function () {\n    // Check if the browser supports IntersectionObserver\n    if (!('IntersectionObserver' in window)) {\n      // If not supported, optionally set to visible or handle fallback logic\n      setIsVisible(true); // Fallback: Set to visible\n\n      return;\n    } // Create an IntersectionObserver instance\n\n    var observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        setIsVisible(entry.isIntersecting);\n      });\n    });\n    var element = ref === null || ref === void 0 ? void 0 : ref.current; // Start observing the target element\n\n    if (element) {\n      observer.observe(element);\n    } // Cleanup function to unobserve the element when the component unmounts or dependencies change\n\n    return function () {\n      if (element) {\n        observer.unobserve(element);\n      }\n    };\n  }, [ref]);\n  return isVisible;\n};\nexport default useIntersectionObserver;","map":{"version":3,"names":["useState","useEffect","useIntersectionObserver","ref","_useState","isVisible","setIsVisible","window","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","element","current","observe","unobserve"],"sources":["E:/Projects/LMS/client/node_modules/rsuite-table/es/utils/useIntersectionObserver.js"],"sourcesContent":["'use client';\nimport { useState, useEffect } from 'react';\n/**\n * useIntersectionObserver Hook\n *\n * @param ref - Ref object of the element to be observed\n */\n\nvar useIntersectionObserver = function useIntersectionObserver(ref) {\n  var _useState = useState(false),\n      isVisible = _useState[0],\n      setIsVisible = _useState[1];\n\n  useEffect(function () {\n    // Check if the browser supports IntersectionObserver\n    if (!('IntersectionObserver' in window)) {\n      // If not supported, optionally set to visible or handle fallback logic\n      setIsVisible(true); // Fallback: Set to visible\n\n      return;\n    } // Create an IntersectionObserver instance\n\n\n    var observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        setIsVisible(entry.isIntersecting);\n      });\n    });\n    var element = ref === null || ref === void 0 ? void 0 : ref.current; // Start observing the target element\n\n    if (element) {\n      observer.observe(element);\n    } // Cleanup function to unobserve the element when the component unmounts or dependencies change\n\n\n    return function () {\n      if (element) {\n        observer.unobserve(element);\n      }\n    };\n  }, [ref]);\n  return isVisible;\n};\n\nexport default useIntersectionObserver;"],"mappings":"AAAA,YAAY;;AACZ,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C;AACA;AACA;AACA;AACA;;AAEA,IAAIC,uBAAuB,GAAG,SAASA,uBAAuBA,CAACC,GAAG,EAAE;EAClE,IAAIC,SAAS,GAAGJ,QAAQ,CAAC,KAAK,CAAC;IAC3BK,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC;IACxBE,YAAY,GAAGF,SAAS,CAAC,CAAC,CAAC;EAE/BH,SAAS,CAAC,YAAY;IACpB;IACA,IAAI,EAAE,sBAAsB,IAAIM,MAAM,CAAC,EAAE;MACvC;MACAD,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;;MAEpB;IACF,CAAC,CAAC;;IAGF,IAAIE,QAAQ,GAAG,IAAIC,oBAAoB,CAAC,UAAUC,OAAO,EAAE;MACzDA,OAAO,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAE;QAC/BN,YAAY,CAACM,KAAK,CAACC,cAAc,CAAC;MACpC,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,IAAIC,OAAO,GAAGX,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACY,OAAO,CAAC,CAAC;;IAErE,IAAID,OAAO,EAAE;MACXN,QAAQ,CAACQ,OAAO,CAACF,OAAO,CAAC;IAC3B,CAAC,CAAC;;IAGF,OAAO,YAAY;MACjB,IAAIA,OAAO,EAAE;QACXN,QAAQ,CAACS,SAAS,CAACH,OAAO,CAAC;MAC7B;IACF,CAAC;EACH,CAAC,EAAE,CAACX,GAAG,CAAC,CAAC;EACT,OAAOE,SAAS;AAClB,CAAC;AAED,eAAeH,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}